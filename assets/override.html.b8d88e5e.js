import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,e}from"./app.83f8fc33.js";const c={},i=e(`<h1 id="方法的重写" tabindex="-1"><a class="header-anchor" href="#方法的重写" aria-hidden="true">#</a> 方法的重写</h1><h2 id="什么是方法的重写❓" tabindex="-1"><a class="header-anchor" href="#什么是方法的重写❓" aria-hidden="true">#</a> 什么是方法的重写❓</h2><div class="custom-container tip"><p class="custom-container-title">override 或 overwrite</p><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p></div><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><p><code>重写</code>以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p><h2 id="举例" tabindex="-1"><a class="header-anchor" href="#举例" aria-hidden="true">#</a> 举例</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">{</span>
    <span class="token comment">//求面积</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cylinder</span> <span class="token keyword">extends</span> <span class="token class-name">Circle</span><span class="token punctuation">{</span>
    <span class="token comment">//求表面积</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Account</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">double</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">CheckAccount</span> <span class="token keyword">extends</span> <span class="token class-name">Account</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">double</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重写的规则" tabindex="-1"><a class="header-anchor" href="#重写的规则" aria-hidden="true">#</a> 重写的规则</h2><p>方法的声明</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>权限修饰符 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token keyword">throws</span> 异常的类型 <span class="token punctuation">{</span>
    方法体
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 <ul><li>特殊情况：子类不能重写父类中声明为private权限的方法</li></ul></li><li>返回值类型： <ul><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型( 必须也是double)</li></ul></li><li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</li></ol></div><p><strong>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</strong></p><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><blockquote><p>区分方法的<code>重写</code>和<code>重载</code>？</p></blockquote><p>答：</p><ol><li>二者的概念：</li><li>重载和重写的具体规则</li><li>重载：不表现为多态性。</li></ol><p><code>重写</code>：表现为多态性。<br><code>重载</code> ：是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。<br> 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为<code>早绑定</code>或<code>静态绑定</code>；</p><p>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为<code>晚绑定</code>或<code>动态绑定</code>。</p><p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>`,19),l=[i];function o(t,p){return s(),a("div",null,l)}const r=n(c,[["render",o],["__file","override.html.vue"]]);export{r as default};
