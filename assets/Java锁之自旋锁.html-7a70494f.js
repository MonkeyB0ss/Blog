const e=JSON.parse('{"key":"v-2fa9d5fe","path":"/other/audition/JUC/Java%E9%94%81%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81.html","title":"Java锁之自旋锁","lang":"zh-CN","frontmatter":{"date":"2023-03-31T00:00:00.000Z","category":"面试","tag":["JUC"]},"headers":[{"level":2,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":2,"title":"手写自旋锁","slug":"手写自旋锁","link":"#手写自旋锁","children":[]}],"git":{"createdTime":1680279876000,"updatedTime":1680449106000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":2}]},"readingTime":{"minutes":1.92,"words":575},"filePathRelative":"other/audition/JUC/Java锁之自旋锁.md","localizedDate":"2023年3月31日","excerpt":"<h1> Java锁之自旋锁</h1>\\n<p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>\\n<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p>\\n<p></p>\\n<h2> 优缺点</h2>\\n<p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p>\\n<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>\\n<h2> 手写自旋锁</h2>\\n<p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p>"}');export{e as data};
