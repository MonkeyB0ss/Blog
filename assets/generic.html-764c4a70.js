const e=JSON.parse('{"key":"v-558dbc20","path":"/java/java-advanced/generic/generic.html","title":"泛型的理解","lang":"zh-CN","frontmatter":{"date":"2022-12-03T00:00:00.000Z","category":"基础进阶","tag":["JAVA"]},"headers":[{"level":2,"title":"泛型的概念","slug":"泛型的概念","link":"#泛型的概念","children":[]},{"level":2,"title":"泛型的引入背景","slug":"泛型的引入背景","link":"#泛型的引入背景","children":[]}],"git":{"createdTime":1670051528000,"updatedTime":1670051528000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":1}]},"readingTime":{"minutes":0.95,"words":286},"filePathRelative":"java/java-advanced/generic/generic.md","localizedDate":"2022年12月3日","excerpt":"<h1> 泛型的理解</h1>\\n<h2> 泛型的概念</h2>\\n<p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返\\n回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、 创建对象时确定（即传入实际的类型参数，也称为类型实参）。</p>\\n<h2> 泛型的引入背景</h2>\\n<p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在<mark>JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决</mark>。\\n因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时<mark>把元素的类型设计成一个参数，这个类型参数叫做泛型</mark>。\\n<code>Collection&lt;E&gt;</code>,<code>List&lt;E&gt;</code>,<code>ArrayList&lt;E&gt;</code>这个<code>&lt;E&gt;</code>就是类型参数，即泛型。</p>"}');export{e as data};
