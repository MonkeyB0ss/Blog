import{_ as a,X as n,Y as s,a2 as e}from"./framework-a20dc394.js";const t="/assets/img_10-960c87ae.png",p={},l=e(`<h1 id="volatile禁止指令重排" tabindex="-1"><a class="header-anchor" href="#volatile禁止指令重排" aria-hidden="true">#</a> Volatile禁止指令重排</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>单线程环境里面确保最终执行结果和代码顺序的结果一致</p><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p><p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><h2 id="指令重排-example-1" tabindex="-1"><a class="header-anchor" href="#指令重排-example-1" aria-hidden="true">#</a> 指令重排 - example 1</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mySort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
	y <span class="token operator">=</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照正常单线程环境，执行顺序是 1 2 3 4</p><p>但是在多线程环境下，可能出现以下的顺序：</p><ul><li>2 1 3 4</li><li>1 3 2 4</li></ul><p>上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样</p><p>但是指令重排也是有限制的，即不会出现下面的顺序</p><ul><li>4 3 2 1</li></ul><p>因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性</p><p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h3><p>int a,b,x,y = 0</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td></td><td></td></tr><tr><td>x = 0; y = 0</td><td></td></tr></tbody></table><p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td></td><td></td></tr><tr><td>x = 2; y = 1</td><td></td></tr></tbody></table><p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性</p><h2 id="指令重排-example-2" tabindex="-1"><a class="header-anchor" href="#指令重排-example-2" aria-hidden="true">#</a> 指令重排 - example 2</h2><p>比如下面这段代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResortSeqDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;reValue:&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们按照正常的顺序，分别调用method01() 和 method02() 那么，最终输出就是 a = 6</p><p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;reValue:&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;reValue:&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p><p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>这样就需要通过volatile来修饰，来保证线程安全性</p><h2 id="volatile针对指令重排做了啥" tabindex="-1"><a class="header-anchor" href="#volatile针对指令重排做了啥" aria-hidden="true">#</a> Volatile针对指令重排做了啥</h2><p>Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p><img src="`+t+'" alt="img_10.png"></p><p>也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p><h2 id="线程安全获得保证" tabindex="-1"><a class="header-anchor" href="#线程安全获得保证" aria-hidden="true">#</a> 线程安全获得保证</h2><p>工作内存与主内存同步延迟现象导致的可见性问题</p><ul><li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li></ul><p>对于指令重排导致的可见性问题和有序性问题</p><ul><li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li></ul>',45),o=[l];function i(c,r){return n(),s("div",null,o)}const u=a(p,[["render",i],["__file","Volatile禁止指令重排.html.vue"]]);export{u as default};
