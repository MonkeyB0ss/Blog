import{_ as n,X as s,Y as a,a2 as t}from"./framework-a20dc394.js";const e="/Blog/assets/img_7-6f7b1560.png",o="/Blog/assets/img_8-44cbce20.png",p="/Blog/assets/img_9-2dbfbb8e.png",c={},i=t('<h1 id="gc-roots" tabindex="-1"><a class="header-anchor" href="#gc-roots" aria-hidden="true">#</a> GC Roots</h1><h2 id="jvm垃圾回收的时候如何确定垃圾-是否知道什么是gc-roots" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收的时候如何确定垃圾-是否知道什么是gc-roots" aria-hidden="true">#</a> JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</h2><h3 id="什么是垃圾" tabindex="-1"><a class="header-anchor" href="#什么是垃圾" aria-hidden="true">#</a> 什么是垃圾</h3><p>简单来说就是内存中已经不再被使用的空间就是垃圾</p><h3 id="如何判断一个对象是否可以被回收" tabindex="-1"><a class="header-anchor" href="#如何判断一个对象是否可以被回收" aria-hidden="true">#</a> 如何判断一个对象是否可以被回收</h3><h4 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h4><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p><p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p><p>每当有一个地方引用它，计数器值加1</p><p>每当有一个引用失效，计数器值减1</p><p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><p><img src="'+e+'" alt="img_7.png"></p><h4 id="枚举根节点做可达性分析" tabindex="-1"><a class="header-anchor" href="#枚举根节点做可达性分析" aria-hidden="true">#</a> 枚举根节点做可达性分析</h4><p>根搜索路径算法</p><p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p><p><img src="'+o+'" alt="img_8.png"></p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是一组必须活跃的引用</p><p>基本思路就是通过一系列名为 GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><p><img src="'+p+`" alt="img_9.png"></p><p>必须从GC Roots对象开始，这个类似于linux的 / 也就是根目录</p><p>蓝色部分是从GC Roots出发，能够循环可达</p><p>而白色部分，从GC Roots出发，无法到达</p><h4 id="一句话理解gc-roots" tabindex="-1"><a class="header-anchor" href="#一句话理解gc-roots" aria-hidden="true">#</a> 一句话理解GC Roots</h4><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p><p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><h4 id="那些对象可以当做gc-roots" tabindex="-1"><a class="header-anchor" href="#那些对象可以当做gc-roots" aria-hidden="true">#</a> 那些对象可以当做GC Roots</h4><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li></ul><h4 id="代码说明" tabindex="-1"><a class="header-anchor" href="#代码说明" aria-hidden="true">#</a> 代码说明</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCRootDemo</span> <span class="token punctuation">{</span>
    <span class="token comment">// 方法区中的类静态属性引用的对象</span>
    <span class="token comment">// private static GCRootDemo2 t2;</span>

    <span class="token comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span>
    <span class="token comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第一种，虚拟机栈中的引用对象</span>
        <span class="token class-name">GCRootDemo</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GCRootDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;第一次GC完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,34),l=[i];function r(d,u){return s(),a("div",null,l)}const k=n(c,[["render",r],["__file","GC Roots.html.vue"]]);export{k as default};
