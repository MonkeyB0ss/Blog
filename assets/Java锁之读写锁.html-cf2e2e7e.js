const e=JSON.parse('{"key":"v-c60a508e","path":"/other/audition/JUC/Java%E9%94%81%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81.html","title":"Java锁之读写锁","lang":"zh-CN","frontmatter":{"date":"2023-03-31T00:00:00.000Z","category":"面试","tag":["JUC"]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"为什么会有写锁和读锁","slug":"为什么会有写锁和读锁","link":"#为什么会有写锁和读锁","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]}],"git":{"createdTime":1680279876000,"updatedTime":1680449106000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":2}]},"readingTime":{"minutes":5.31,"words":1592},"filePathRelative":"other/audition/JUC/Java锁之读写锁.md","localizedDate":"2023年3月31日","excerpt":"<h1> Java锁之读写锁</h1>\\n<h2> 概念</h2>\\n<p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p>\\n<p>共享锁：指该锁可以被多个线程锁持有</p>\\n<p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p>\\n<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>\\n<h2> 为什么会有写锁和读锁</h2>\\n<p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p>"}');export{e as data};
