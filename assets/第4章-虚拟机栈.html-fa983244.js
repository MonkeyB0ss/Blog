const l=JSON.parse('{"key":"v-ba5bb3ce","path":"/java/JVM/memory-garbageCollection/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.html","title":"第4章-虚拟机栈","lang":"zh-CN","frontmatter":{"date":"2023-03-16T00:00:00.000Z","category":"JVM","tag":["JAVA"]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[{"level":3,"title":"虚拟机栈的出现背景","slug":"虚拟机栈的出现背景","link":"#虚拟机栈的出现背景","children":[]},{"level":3,"title":"内存中的栈与堆","slug":"内存中的栈与堆","link":"#内存中的栈与堆","children":[]},{"level":3,"title":"虚拟机栈基本内容","slug":"虚拟机栈基本内容","link":"#虚拟机栈基本内容","children":[]},{"level":3,"title":"虚拟机栈的特点","slug":"虚拟机栈的特点","link":"#虚拟机栈的特点","children":[]},{"level":3,"title":"虚拟机栈的异常","slug":"虚拟机栈的异常","link":"#虚拟机栈的异常","children":[]},{"level":3,"title":"设置栈内存大小","slug":"设置栈内存大小","link":"#设置栈内存大小","children":[]}]},{"level":2,"title":"栈的存储单位","slug":"栈的存储单位","link":"#栈的存储单位","children":[{"level":3,"title":"栈中存储什么？","slug":"栈中存储什么","link":"#栈中存储什么","children":[]},{"level":3,"title":"栈运行原理","slug":"栈运行原理","link":"#栈运行原理","children":[]},{"level":3,"title":"栈帧的内部结构","slug":"栈帧的内部结构","link":"#栈帧的内部结构","children":[]}]},{"level":2,"title":"局部变量表","slug":"局部变量表","link":"#局部变量表","children":[{"level":3,"title":"认识局部变量表","slug":"认识局部变量表","link":"#认识局部变量表","children":[]},{"level":3,"title":"关于Slot的理解","slug":"关于slot的理解","link":"#关于slot的理解","children":[]},{"level":3,"title":"Slot代码示例","slug":"slot代码示例","link":"#slot代码示例","children":[]},{"level":3,"title":"Slot的重复利用","slug":"slot的重复利用","link":"#slot的重复利用","children":[]},{"level":3,"title":"静态变量与局部变量的对比","slug":"静态变量与局部变量的对比","link":"#静态变量与局部变量的对比","children":[]},{"level":3,"title":"补充说明","slug":"补充说明","link":"#补充说明","children":[]}]},{"level":2,"title":"操作数栈","slug":"操作数栈","link":"#操作数栈","children":[{"level":3,"title":"操作数栈的特点","slug":"操作数栈的特点","link":"#操作数栈的特点","children":[]},{"level":3,"title":"操作数栈的作用","slug":"操作数栈的作用","link":"#操作数栈的作用","children":[]}]},{"level":2,"title":"操作数栈代码追踪","slug":"操作数栈代码追踪","link":"#操作数栈代码追踪","children":[{"level":3,"title":"一步一步看流程","slug":"一步一步看流程","link":"#一步一步看流程","children":[]},{"level":3,"title":"小问题","slug":"小问题","link":"#小问题","children":[]}]},{"level":2,"title":"栈顶缓存技术","slug":"栈顶缓存技术","link":"#栈顶缓存技术","children":[]},{"level":2,"title":"态链接","slug":"态链接","link":"#态链接","children":[]},{"level":2,"title":"方法的调用","slug":"方法的调用","link":"#方法的调用","children":[{"level":3,"title":"静态链接与动态链接","slug":"静态链接与动态链接","link":"#静态链接与动态链接","children":[]},{"level":3,"title":"早期绑定与晚期绑定","slug":"早期绑定与晚期绑定","link":"#早期绑定与晚期绑定","children":[]},{"level":3,"title":"多态与绑定","slug":"多态与绑定","link":"#多态与绑定","children":[]},{"level":3,"title":"动态语言和静态语言","slug":"动态语言和静态语言","link":"#动态语言和静态语言","children":[]},{"level":3,"title":"Java语言中方法重写的本质","slug":"java语言中方法重写的本质","link":"#java语言中方法重写的本质","children":[]},{"level":3,"title":"虚方法表","slug":"虚方法表","link":"#虚方法表","children":[]}]},{"level":2,"title":"方法返回地址","slug":"方法返回地址","link":"#方法返回地址","children":[]},{"level":2,"title":"一些附加信息","slug":"一些附加信息","link":"#一些附加信息","children":[]},{"level":2,"title":"栈相关面试题","slug":"栈相关面试题","link":"#栈相关面试题","children":[{"level":3,"title":"举例栈溢出的情况？","slug":"举例栈溢出的情况","link":"#举例栈溢出的情况","children":[]},{"level":3,"title":"调整栈大小，就能保证不出现溢出么？","slug":"调整栈大小-就能保证不出现溢出么","link":"#调整栈大小-就能保证不出现溢出么","children":[]},{"level":3,"title":"分配的栈内存越大越好么？","slug":"分配的栈内存越大越好么","link":"#分配的栈内存越大越好么","children":[]},{"level":3,"title":"垃圾回收是否涉及到虚拟机栈？","slug":"垃圾回收是否涉及到虚拟机栈","link":"#垃圾回收是否涉及到虚拟机栈","children":[]},{"level":3,"title":"方法中定义的局部变量是否线程安全？","slug":"方法中定义的局部变量是否线程安全","link":"#方法中定义的局部变量是否线程安全","children":[]}]}],"git":{"createdTime":1678981862000,"updatedTime":1678981862000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":1}]},"readingTime":{"minutes":33.86,"words":10158},"filePathRelative":"java/JVM/memory-garbageCollection/第4章-虚拟机栈.md","localizedDate":"2023年3月16日","excerpt":"<h1> 第4章-虚拟机栈</h1>\\n<h2> 简介</h2>\\n<h3> 虚拟机栈的出现背景</h3>\\n<ol>\\n<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>\\n<li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>\\n</ol>\\n<h3> 内存中的栈与堆</h3>\\n<ol>\\n<li>首先栈是运行时的单位，而堆是存储的单位。</li>\\n<li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li>\\n</ol>"}');export{l as data};
