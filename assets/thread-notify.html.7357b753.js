import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as i,e as t}from"./app.c44abe88.js";const o="/Blog/assets/notify1.705ac492.png",l="/Blog/assets/notify2.835f97a1.png",d={},c=t('<h1 id="线程通信" tabindex="-1"><a class="header-anchor" href="#线程通信" aria-hidden="true">#</a> 线程通信</h1><h2 id="线程通信涉及到的三个方法" tabindex="-1"><a class="header-anchor" href="#线程通信涉及到的三个方法" aria-hidden="true">#</a> 线程通信涉及到的三个方法</h2><ul><li><code>wait()</code>: 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</li><li><code>notify()</code>: 一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li><code>notifyAll()</code>: 一旦执行此方法，就会唤醒所有被wait的线程。</li></ul><h2 id="说明" tabindex="-1"><a class="header-anchor" href="#说明" aria-hidden="true">#</a> 说明</h2><ol><li><code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>三个方法必须使用在同步代码块或同步方法中。</li><li><code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现<mark>IllegalMonitorStateException异常</mark></li><li>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</li></ol><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><p>sleep() 和 wait()的异同？</p><ol><li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li><li>不同点： <ul><li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li></ul></li></ol><h2 id="释放锁的操作" tabindex="-1"><a class="header-anchor" href="#释放锁的操作" aria-hidden="true">#</a> 释放锁的操作</h2><p><img src="'+o+'" alt="img.png"></p><h2 id="不会释放锁的操作" tabindex="-1"><a class="header-anchor" href="#不会释放锁的操作" aria-hidden="true">#</a> 不会释放锁的操作</h2><p><img src="'+l+'" alt="img.png"></p>',12),r=[c];function n(h,s){return a(),i("div",null,r)}const _=e(d,[["render",n],["__file","thread-notify.html.vue"]]);export{_ as default};
