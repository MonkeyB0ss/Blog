const l=JSON.parse('{"key":"v-4a0adab0","path":"/java/JVM/memory-garbageCollection/%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html","title":"第3章-运行时数据区概述及线程","lang":"zh-CN","frontmatter":{"date":"2023-03-13T00:00:00.000Z","category":"JVM","tag":["JAVA"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"运行时数据区结构","slug":"运行时数据区结构","link":"#运行时数据区结构","children":[{"level":3,"title":"运行时数据区与内存","slug":"运行时数据区与内存","link":"#运行时数据区与内存","children":[]},{"level":3,"title":"线程的内存空间","slug":"线程的内存空间","link":"#线程的内存空间","children":[]},{"level":3,"title":"Runtime类","slug":"runtime类","link":"#runtime类","children":[]}]},{"level":2,"title":"线程","slug":"线程","link":"#线程","children":[{"level":3,"title":"JVM 线程","slug":"jvm-线程","link":"#jvm-线程","children":[]},{"level":3,"title":"JVM 系统线程","slug":"jvm-系统线程","link":"#jvm-系统线程","children":[]}]},{"level":2,"title":"程序计数器(PC寄存器)","slug":"程序计数器-pc寄存器","link":"#程序计数器-pc寄存器","children":[{"level":3,"title":"PC寄存器介绍","slug":"pc寄存器介绍","link":"#pc寄存器介绍","children":[]},{"level":3,"title":"PC寄存器的作用","slug":"pc寄存器的作用","link":"#pc寄存器的作用","children":[]},{"level":3,"title":"举例","slug":"举例","link":"#举例","children":[]},{"level":3,"title":"两个面试题","slug":"两个面试题","link":"#两个面试题","children":[]},{"level":3,"title":"CPU 时间片","slug":"cpu-时间片","link":"#cpu-时间片","children":[]}]},{"level":2,"title":"本地方法接口","slug":"本地方法接口","link":"#本地方法接口","children":[{"level":3,"title":"本地方法","slug":"本地方法","link":"#本地方法","children":[]},{"level":3,"title":"举例","slug":"举例-1","link":"#举例-1","children":[]},{"level":3,"title":"为什么要使用 Native Method？","slug":"为什么要使用-native-method","link":"#为什么要使用-native-method","children":[]}]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]}],"git":{"createdTime":1678716384000,"updatedTime":1678981862000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":2}]},"readingTime":{"minutes":13.89,"words":4167},"filePathRelative":"java/JVM/memory-garbageCollection/第3章-运行时数据区.md","localizedDate":"2023年3月13日","excerpt":"<blockquote>\\n<p>此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。</p>\\n</blockquote>\\n<h1> 第3章-运行时数据区概述及线程</h1>\\n<h2> 前言</h2>\\n<p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>\\n<p></p>\\n<p>当我们通过前面的：类的加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\\n<p></p>\\n<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>"}');export{l as data};
