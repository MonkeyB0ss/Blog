const l=JSON.parse('{"key":"v-c96633fe","path":"/java/JVM/memory-garbageCollection/%E7%AC%AC5%E7%AB%A0-%E5%A0%86.html","title":"第5章-堆","lang":"zh-CN","frontmatter":{"date":"2023-03-21T00:00:00.000Z","category":"JVM","tag":["JAVA"]},"headers":[{"level":2,"title":"堆的核心概述","slug":"堆的核心概述","link":"#堆的核心概述","children":[{"level":3,"title":"堆与进程","slug":"堆与进程","link":"#堆与进程","children":[]},{"level":3,"title":"堆内存细分","slug":"堆内存细分","link":"#堆内存细分","children":[]}]},{"level":2,"title":"JVisualVM可视化查看堆内存","slug":"jvisualvm可视化查看堆内存","link":"#jvisualvm可视化查看堆内存","children":[]},{"level":2,"title":"设置堆内存大小与 OOM","slug":"设置堆内存大小与-oom","link":"#设置堆内存大小与-oom","children":[{"level":3,"title":"设置堆内存","slug":"设置堆内存","link":"#设置堆内存","children":[]},{"level":3,"title":"OOM","slug":"oom","link":"#oom","children":[]}]},{"level":2,"title":"年轻代与老年代","slug":"年轻代与老年代","link":"#年轻代与老年代","children":[]},{"level":2,"title":"图解对象分配过程","slug":"图解对象分配过程","link":"#图解对象分配过程","children":[{"level":3,"title":"图解对象分配（一般情况）","slug":"图解对象分配-一般情况","link":"#图解对象分配-一般情况","children":[]},{"level":3,"title":"特殊情况说明","slug":"特殊情况说明","link":"#特殊情况说明","children":[]},{"level":3,"title":"常用调优工具","slug":"常用调优工具","link":"#常用调优工具","children":[]}]},{"level":2,"title":"GC分类","slug":"gc分类","link":"#gc分类","children":[{"level":3,"title":"Young GC","slug":"young-gc","link":"#young-gc","children":[]},{"level":3,"title":"Major/Full GC","slug":"major-full-gc","link":"#major-full-gc","children":[]},{"level":3,"title":"GC日志分析","slug":"gc日志分析","link":"#gc日志分析","children":[]}]},{"level":2,"title":"堆空间分代思想","slug":"堆空间分代思想","link":"#堆空间分代思想","children":[]},{"level":2,"title":"对象内存分配策略","slug":"对象内存分配策略","link":"#对象内存分配策略","children":[]},{"level":2,"title":"TLAB为对象分配内存（保证线程安全）","slug":"tlab为对象分配内存-保证线程安全","link":"#tlab为对象分配内存-保证线程安全","children":[{"level":3,"title":"为什么有 TLAB","slug":"为什么有-tlab","link":"#为什么有-tlab","children":[]},{"level":3,"title":"什么是 TLAB","slug":"什么是-tlab","link":"#什么是-tlab","children":[]},{"level":3,"title":"TLAB再说明","slug":"tlab再说明","link":"#tlab再说明","children":[]}]},{"level":2,"title":"堆空间参数设置","slug":"堆空间参数设置","link":"#堆空间参数设置","children":[{"level":3,"title":"常用参数设置","slug":"常用参数设置","link":"#常用参数设置","children":[]},{"level":3,"title":"空间分配担保","slug":"空间分配担保","link":"#空间分配担保","children":[]}]},{"level":2,"title":"堆是分配对象的唯一选择么？","slug":"堆是分配对象的唯一选择么","link":"#堆是分配对象的唯一选择么","children":[{"level":3,"title":"逃逸分析","slug":"逃逸分析","link":"#逃逸分析","children":[]},{"level":3,"title":"代码优化","slug":"代码优化","link":"#代码优化","children":[]},{"level":3,"title":"栈上分配","slug":"栈上分配","link":"#栈上分配","children":[]},{"level":3,"title":"同步省略（同步消除）","slug":"同步省略-同步消除","link":"#同步省略-同步消除","children":[]},{"level":3,"title":"标量替换","slug":"标量替换","link":"#标量替换","children":[]},{"level":3,"title":"逃逸分析的不足","slug":"逃逸分析的不足","link":"#逃逸分析的不足","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1679330725000,"updatedTime":1679330725000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":1}]},"readingTime":{"minutes":33.52,"words":10056},"filePathRelative":"java/JVM/memory-garbageCollection/第5章-堆.md","localizedDate":"2023年3月21日","excerpt":"<h1> 第5章-堆</h1>\\n<h2> 堆的核心概述</h2>\\n<h3> 堆与进程</h3>\\n<ol>\\n<li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li>\\n<li>但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li>\\n</ol>\\n<p></p>\\n<ol>\\n<li>\\n<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\\n</li>\\n<li>\\n<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</p>\\n</li>\\n<li>\\n<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>\\n</li>\\n<li>\\n<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p>\\n</li>\\n<li>\\n<p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>\\n<ul>\\n<li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>\\n</ul>\\n</li>\\n<li>\\n<p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>\\n</li>\\n<li>\\n<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>\\n<ul>\\n<li>也就是触发了GC的时候，才会进行回收</li>\\n<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>\\n</ul>\\n</li>\\n<li>\\n<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>\\n</li>\\n</ol>"}');export{l as data};
