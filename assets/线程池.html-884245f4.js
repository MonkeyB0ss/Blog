const l=JSON.parse('{"key":"v-55b50432","path":"/other/audition/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html","title":"线程池","lang":"zh-CN","frontmatter":{"date":"2023-03-31T00:00:00.000Z","category":"面试","tag":["JUC"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"Callable接口","slug":"callable接口","link":"#callable接口","children":[{"level":3,"title":"注意","slug":"注意","link":"#注意","children":[]}]},{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[{"level":3,"title":"为什么用线程池","slug":"为什么用线程池","link":"#为什么用线程池","children":[]},{"level":3,"title":"线程池的好处","slug":"线程池的好处","link":"#线程池的好处","children":[]},{"level":3,"title":"架构说明","slug":"架构说明","link":"#架构说明","children":[]},{"level":3,"title":"创建线程池","slug":"创建线程池","link":"#创建线程池","children":[]},{"level":3,"title":"创建周期性执行任务的线程池","slug":"创建周期性执行任务的线程池","link":"#创建周期性执行任务的线程池","children":[]}]},{"level":2,"title":"底层实现","slug":"底层实现","link":"#底层实现","children":[]},{"level":2,"title":"线程池的重要参数","slug":"线程池的重要参数","link":"#线程池的重要参数","children":[]},{"level":2,"title":"拒绝策略","slug":"拒绝策略","link":"#拒绝策略","children":[]},{"level":2,"title":"线程池底层工作原理","slug":"线程池底层工作原理","link":"#线程池底层工作原理","children":[{"level":3,"title":"线程池运行架构图","slug":"线程池运行架构图","link":"#线程池运行架构图","children":[]}]},{"level":2,"title":"为什么不用默认创建的线程池？","slug":"为什么不用默认创建的线程池","link":"#为什么不用默认创建的线程池","children":[]},{"level":2,"title":"手写线程池","slug":"手写线程池","link":"#手写线程池","children":[{"level":3,"title":"采用默认拒绝策略","slug":"采用默认拒绝策略","link":"#采用默认拒绝策略","children":[]},{"level":3,"title":"采用CallerRunsPolicy拒绝策略","slug":"采用callerrunspolicy拒绝策略","link":"#采用callerrunspolicy拒绝策略","children":[]},{"level":3,"title":"采用 DiscardPolicy 拒绝策略","slug":"采用-discardpolicy-拒绝策略","link":"#采用-discardpolicy-拒绝策略","children":[]},{"level":3,"title":"采用DiscardOldestPolicy拒绝策略","slug":"采用discardoldestpolicy拒绝策略","link":"#采用discardoldestpolicy拒绝策略","children":[]}]},{"level":2,"title":"线程池的合理参数","slug":"线程池的合理参数","link":"#线程池的合理参数","children":[]}],"git":{"createdTime":1680279876000,"updatedTime":1680449106000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":2}]},"readingTime":{"minutes":17.36,"words":5207},"filePathRelative":"other/audition/JUC/线程池.md","localizedDate":"2023年3月31日","excerpt":"<h1> 线程池</h1>\\n<h2> 前言</h2>\\n<p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p>\\n<ul>\\n<li>实现Runnable接口</li>\\n<li>实现Callable接口</li>\\n<li>实例化Thread类</li>\\n<li>使用线程池获取</li>\\n</ul>\\n<h2> Callable接口</h2>\\n<p>Callable接口，是一种让线程执行完成后，能够返回结果的</p>\\n<p>在说到Callable接口的时候，我们不得不提到Runnable接口</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token doc-comment comment\\">/**\\n * 实现Runnable接口\\n */</span>\\n<span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">MyThread</span> <span class=\\"token keyword\\">implements</span> <span class=\\"token class-name\\">Runnable</span> <span class=\\"token punctuation\\">{</span>\\n\\n    <span class=\\"token annotation punctuation\\">@Override</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">run</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{l as data};
