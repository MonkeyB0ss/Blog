import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as n,e as o}from"./app.71f9ab67.js";const a="/Blog/assets/transaction1.709e6817.png",d="/Blog/assets/transaction2.76f16b96.png",c={},t=o('<h1 id="第13章-事务基础知识" tabindex="-1"><a class="header-anchor" href="#第13章-事务基础知识" aria-hidden="true">#</a> 第13章_事务基础知识</h1><h2 id="_1-数据库事务概述" tabindex="-1"><a class="header-anchor" href="#_1-数据库事务概述" aria-hidden="true">#</a> <strong>1.</strong> <strong>数据库事务概述</strong></h2><h3 id="_1-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-1-基本概念" aria-hidden="true">#</a> <strong>1.1</strong> <strong>基本概念</strong></h3><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则</strong>：保证所有事务都作为<code>一个工作单元</code> 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>) ，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p><h3 id="_1-2-事务的acid特性" tabindex="-1"><a class="header-anchor" href="#_1-2-事务的acid特性" aria-hidden="true">#</a> <strong>1.2</strong> <strong>事务的ACID特性</strong></h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><h3 id="_1-3-事务的状态" tabindex="-1"><a class="header-anchor" href="#_1-3-事务的状态" aria-hidden="true">#</a> <strong>1.3</strong> <strong>事务的状态</strong></h3><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code> 状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在<code>活动的</code>或者<code>部分提交的</code> 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code> 状态。</p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为<code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code> 。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p><p><img src="'+a+`" alt="img.png"></p><h2 id="_2-如何使用事务" tabindex="-1"><a class="header-anchor" href="#_2-如何使用事务" aria-hidden="true">#</a> <strong>2.</strong> <strong>如何使用事务</strong></h2><h3 id="_2-1-显式事务" tabindex="-1"><a class="header-anchor" href="#_2-1-显式事务" aria-hidden="true">#</a> <strong>2.1</strong> <strong>显式事务</strong></h3><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">BEGIN</span><span class="token punctuation">;</span> 
<span class="token comment">#或者 </span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>：</p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p><strong>步骤2</strong>：一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 回滚事务。即撤销正在进行的所有没有提交的修改 </span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span> 

<span class="token comment"># 将事务回滚到某个保存点。 </span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> <span class="token punctuation">[</span><span class="token keyword">SAVEPOINT</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中关于SAVEPOINT相关操作有：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。</span>
<span class="token keyword">SAVEPOINT</span> 保存点名称<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 删除某个保存点</span>
<span class="token keyword">RELEASE</span> <span class="token keyword">SAVEPOINT</span> 保存点名称<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-隐式事务" tabindex="-1"><a class="header-anchor" href="#_2-2-隐式事务" aria-hidden="true">#</a> <strong>2.2</strong> <strong>隐式事务</strong></h3><ul><li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li></ul><h3 id="_2-3-隐式提交数据的情况" tabindex="-1"><a class="header-anchor" href="#_2-3-隐式提交数据的情况" aria-hidden="true">#</a> <strong>2.3</strong> <strong>隐式提交数据的情况</strong></h3><ul><li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p></li><li><p><strong>隐式使用或修改mysql数据库中的表</strong></p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><ul><li>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code> 上一个事务。</li><li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li></ul></li></ul><h2 id="_3-事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-事务隔离级别" aria-hidden="true">#</a> <strong>3.</strong> <strong>事务隔离级别</strong></h2><h3 id="_3-1-数据并发问题" tabindex="-1"><a class="header-anchor" href="#_3-1-数据并发问题" aria-hidden="true">#</a> <strong>3.1</strong> <strong>数据并发问题</strong></h3><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code> 的数据，那就意味着发生了<code>脏写</code></p><p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code> ，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p><p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p><p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code> 同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p><p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><strong>注意1：</strong></p><p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code> ，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2：</strong></p><p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code> 的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p><h3 id="_3-2-sql中的四种隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-2-sql中的四种隔离级别" aria-hidden="true">#</a> <strong>3.2 SQL中的四种隔离级别</strong></h3><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><img src="`+d+`" alt="img.png"></p><h3 id="_3-3-如何设置事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-3-如何设置事务的隔离级别" aria-hidden="true">#</a> <strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> 隔离级别<span class="token punctuation">;</span> 
<span class="token comment">#其中，隔离级别格式： </span>
<span class="token operator">&gt;</span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span> 
<span class="token operator">&gt;</span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span> 
<span class="token operator">&gt;</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span> 
<span class="token operator">&gt;</span> <span class="token keyword">SERIALIZABLE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> TRANSACTION_ISOLATION <span class="token operator">=</span> <span class="token string">&#39;隔离级别&#39;</span> 
<span class="token comment">#其中，隔离级别格式： </span>
<span class="token operator">&gt;</span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">UNCOMMITTED</span> 
<span class="token operator">&gt;</span> <span class="token keyword">READ</span><span class="token operator">-</span><span class="token keyword">COMMITTED</span> 
<span class="token operator">&gt;</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> 
<span class="token operator">&gt;</span> <span class="token keyword">SERIALIZABLE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,68),r=[t];function l(i,p){return e(),n("div",null,r)}const k=s(c,[["render",l],["__file","transaction.html.vue"]]);export{k as default};
