import{_ as i,X as a,Y as s,a2 as e}from"./framework-a20dc394.js";const t="/assets/img-abcc7092.png",p="/assets/img_1-5b48fed9.png",n="/assets/img_2-23b23683.png",r="/assets/img_3-370c212d.png",_="/assets/img_4-5e23024e.png",l="/assets/img_5-724e36de.png",c="/assets/img_6-2c1927af.png",g={},m=e('<h1 id="jvm体系结构" tabindex="-1"><a class="header-anchor" href="#jvm体系结构" aria-hidden="true">#</a> JVM体系结构</h1><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h2><p><img src="'+t+'" alt="img.png"></p><p>java gc 主要回收的是 方法区 和 堆中的内容</p><p><img src="'+p+'" alt="img_1.png"></p><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器" aria-hidden="true">#</a> 类加载器</h2><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><h2 id="常见的垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#常见的垃圾回收算法" aria-hidden="true">#</a> 常见的垃圾回收算法</h2><ul><li>引用计数</li></ul><p><img src="'+n+'" alt="img_2.png"></p><p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p><ul><li>复制</li></ul><p>复制算法在年轻代的时候，进行使用，复制时候有交换</p><p><img src="'+r+'" alt="img_3.png"></p><p><img src="'+_+'" alt="img_4.png"></p><p>优点：没有产生内存碎片</p><ul><li>标记清除</li></ul><p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p><p><img src="'+l+'" alt="img_5.png"></p><ul><li>标记整理</li></ul><p>标记清除整理</p><p><img src="'+c+'" alt="img_6.png"></p><p>但是需要付出代价，因为移动对象需要成本</p>',23),o=[m];function d(h,u){return a(),s("div",null,o)}const b=i(g,[["render",d],["__file","JVM体系结构.html.vue"]]);export{b as default};
