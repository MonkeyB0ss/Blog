import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as r,e as s}from"./app.21f1e6f9.js";const t="/Blog/assets/MS-copy1.4bd4fa44.png",n="/Blog/assets/MS-copy2.098772b2.png",a="/Blog/assets/MS-copy3.f8ad2297.png",d="/Blog/assets/MS-copy4.82775f4c.png",c="/Blog/assets/MS-copy5.c380db9c.png",p={},g=s('<h1 id="第18章-主从复制" tabindex="-1"><a class="header-anchor" href="#第18章-主从复制" aria-hidden="true">#</a> 第18章_主从复制</h1><h2 id="_1-主从复制概述" tabindex="-1"><a class="header-anchor" href="#_1-主从复制概述" aria-hidden="true">#</a> <strong>1.</strong> <strong>主从复制概述</strong></h2><h3 id="_1-1-如何提升数据库并发能力" tabindex="-1"><a class="header-anchor" href="#_1-1-如何提升数据库并发能力" aria-hidden="true">#</a> <strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h3><p>一般应用对数据库而言都是&quot;<code>读多写少</code>&quot;，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code> 、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code> ，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h3 id="_1-2-主从复制的作用" tabindex="-1"><a class="header-anchor" href="#_1-2-主从复制的作用" aria-hidden="true">#</a> <strong>1.2</strong> <strong>主从复制的作用</strong></h3><p><strong>第1个作用：读写分离。</strong></p><p><strong>第2个作用就是数据备份。</strong></p><p><strong>第3个作用是具有高可用性。</strong></p><h2 id="_2-主从复制的原理" tabindex="-1"><a class="header-anchor" href="#_2-主从复制的原理" aria-hidden="true">#</a> <strong>2.</strong> <strong>主从复制的原理</strong></h2><h3 id="_2-1-原理剖析" tabindex="-1"><a class="header-anchor" href="#_2-1-原理剖析" aria-hidden="true">#</a> <strong>2.1</strong> <strong>原理剖析</strong></h3><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="'+t+'" alt="image-20220405164559961"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="'+n+'" alt="image-20220405164718627"></p><p><strong>复制三步骤</strong></p><p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h3 id="_2-2-复制的基本原则" tabindex="-1"><a class="header-anchor" href="#_2-2-复制的基本原则" aria-hidden="true">#</a> <strong>2.2</strong> <strong>复制的基本原则</strong></h3><ul><li><p>每个<code>Slave</code>只有一个<code>Master</code></p></li><li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p></li><li><p>每个<code>Master</code>可以有多个<code>Slave</code></p></li></ul><h2 id="_3-同步数据一致性问题" tabindex="-1"><a class="header-anchor" href="#_3-同步数据一致性问题" aria-hidden="true">#</a> <strong>3.</strong> <strong>同步数据一致性问题</strong></h2><p><strong>主从同步的要求：</strong></p><ul><li><p>读库和写库的数据一致(最终一致)；</p></li><li><p>写数据必须写到写库；</p></li><li><p>读数据必须到读库(不一定)；</p></li></ul><h3 id="_3-1-理解主从延迟问题" tabindex="-1"><a class="header-anchor" href="#_3-1-理解主从延迟问题" aria-hidden="true">#</a> <strong>3.1</strong> <strong>理解主从延迟问题</strong></h3><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><h3 id="_3-2-主从延迟问题原因" tabindex="-1"><a class="header-anchor" href="#_3-2-主从延迟问题原因" aria-hidden="true">#</a> <strong>3.2</strong> <strong>主从延迟问题原因</strong></h3><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢</strong>。造成原因：</p><p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><h3 id="_3-3-如何减少主从延迟" tabindex="-1"><a class="header-anchor" href="#_3-3-如何减少主从延迟" aria-hidden="true">#</a> <strong>3.3</strong> <strong>如何减少主从延迟</strong></h3><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ol><h3 id="_3-4-如何解决一致性问题" tabindex="-1"><a class="header-anchor" href="#_3-4-如何解决一致性问题" aria-hidden="true">#</a> <strong>3.4</strong> <strong>如何解决一致性问题</strong></h3><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p><p><strong>方法</strong> <strong>1：异步复制</strong></p><p><img src="'+a+'" alt="image-20220405165455998"></p><p><strong>方法</strong> <strong>2：半同步复制</strong></p><p><img src="'+d+'" alt="image-20220405165513025"></p><p><strong>方法</strong> <strong>3：组复制</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里&quot;大多数人&quot;（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="'+c+'" alt="image-20220405165650425"></p>',49),i=[g];function l(h,_){return e(),r("div",null,i)}const b=o(p,[["render",l],["__file","MS-copy.html.vue"]]);export{b as default};
