const t=JSON.parse('{"key":"v-fbfb59b8","path":"/java/java-basic/object/instantiation.html","title":"子类对象实例化全过程","lang":"zh-CN","frontmatter":{"date":"2022-11-21T00:00:00.000Z","category":["基础"],"tag":["JAVA"],"description":"理解即可 1. 从结果上看：继承性 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。 2. 从过程上看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object 类中空参的构造器为止。正因为加...","head":[["meta",{"property":"og:url","content":"https://monkeyb0ss.github.io/Blog/java/java-basic/object/instantiation.html"}],["meta",{"property":"og:site_name","content":"MonkeyBoss"}],["meta",{"property":"og:title","content":"子类对象实例化全过程"}],["meta",{"property":"og:description","content":"理解即可 1. 从结果上看：继承性 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。 2. 从过程上看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object 类中空参的构造器为止。正因为加..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-11-22T14:44:48.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"JAVA"}],["meta",{"property":"article:published_time","content":"2022-11-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-11-22T14:44:48.000Z"}]]},"excerpt":"","headers":[],"git":{"createdTime":1669128288000,"updatedTime":1669128288000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":1}]},"readingTime":{"minutes":0.83,"words":250},"filePathRelative":"java/java-basic/object/instantiation.md","localizedDate":"2022年11月21日"}');export{t as data};
