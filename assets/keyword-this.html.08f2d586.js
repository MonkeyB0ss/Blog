import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as t,e as d}from"./app.912b6410.js";const i={},c=d('<h1 id="关键字-this" tabindex="-1"><a class="header-anchor" href="#关键字-this" aria-hidden="true">#</a> 关键字：this</h1><h2 id="可以调用的结构" tabindex="-1"><a class="header-anchor" href="#可以调用的结构" aria-hidden="true">#</a> 可以调用的结构</h2><p><code>属性</code>、<code>方法</code>；<code>构造器</code></p><h2 id="this调用属性、方法" tabindex="-1"><a class="header-anchor" href="#this调用属性、方法" aria-hidden="true">#</a> this调用属性、方法：</h2><p><code>this</code>理解为<code>当前对象</code> 或 <code>当前正在创建的对象</code></p><ol><li><p>在类的方法中，我们可以使用&quot;<code>this</code>.属性&quot;或&quot;<code>this</code>.方法&quot;的方式，调用当前对象属性或方法。但是， 通常情况下，我们都择省略&quot;<code>this</code>.&quot;。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式 的使用&quot;<code>this</code>.变量&quot;的方式，表明此变量是属性，而非形参。</p></li><li><p>在类的构造器中，我们可以使用&quot;<code>this</code>.属性&quot;或&quot;<code>this</code>.方法&quot; 的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略&quot;<code>this</code>.&quot; 。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用&quot;<code>this</code>.变量&quot;的方式，表明此变量是属性，而非形参。</p></li></ol><h2 id="this调用构造器" tabindex="-1"><a class="header-anchor" href="#this调用构造器" aria-hidden="true">#</a> this调用构造器</h2><ol><li>我们在类的构造器中，可以显式的使用&quot;<code>this</code>(形参列表)&quot;方式，调用本类中指定的其他构造器</li><li>构造器中不能通过&quot;<code>this</code>(形参列表)&quot;方式调用自己</li><li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了&quot;<code>this</code>(形参列表)&quot;</li><li>规定：&quot;<code>this</code>(形参列表)&quot;必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个&quot;<code>this</code>(形参列表)&quot;，用来调用其他的构造器</li></ol>',8),h=[c];function s(a,r){return e(),t("div",null,h)}const n=o(i,[["render",s],["__file","keyword-this.html.vue"]]);export{n as default};
