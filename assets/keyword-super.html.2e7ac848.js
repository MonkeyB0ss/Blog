import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as d,e as c}from"./app.21f1e6f9.js";const r={},s=c('<h1 id="关键字-super" tabindex="-1"><a class="header-anchor" href="#关键字-super" aria-hidden="true">#</a> 关键字：super</h1><p><strong><code>super</code>关键字可以理解为：<code>父类的</code></strong></p><h2 id="可以用来调用的结构" tabindex="-1"><a class="header-anchor" href="#可以用来调用的结构" aria-hidden="true">#</a> 可以用来调用的结构</h2><p><code>属性</code>、<code>方法</code>、<code>构造器</code></p><h2 id="super调用属性、方法" tabindex="-1"><a class="header-anchor" href="#super调用属性、方法" aria-hidden="true">#</a> super调用属性、方法</h2><ol><li>我们可以在子类的方法或构造器中。通过使用<code>super.属性</code>或<code>super.方法</code> 的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略<code>super.</code></li><li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用<code>super.属性</code> 的方式，表明调用的是父类中声明的属性。</li><li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用<code>super.方法</code> 的方式，表明调用的是父类中被重写的方法。</li></ol><h2 id="super调用构造器" tabindex="-1"><a class="header-anchor" href="#super调用构造器" aria-hidden="true">#</a> super调用构造器：</h2><ol><li>我们可以在子类的构造器中显式的使用<code>super(形参列表)</code>的方式，调用父类中声明的指定的构造器</li><li><code>super(形参列表)</code>的使用，必须声明在子类构造器的首行！</li><li>我们在类的构造器中，针对于<code>this(形参列表)</code>或<code>super(形参列表)</code>只能二一，不能同时出现</li><li>在构造器的首行，没显式的声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认调用的是父类中空参的构造器：<code>super()</code></li><li>在类的多个构造器中，至少一个类的构造器中使用了<code>super(形参列表)</code>，调用父类中的构造器</li></ol>',8),a=[s];function i(l,t){return o(),d("div",null,a)}const h=e(r,[["render",i],["__file","keyword-super.html.vue"]]);export{h as default};
