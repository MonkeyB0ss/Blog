const e=JSON.parse('{"key":"v-5b3d0bee","path":"/java/java-basic/object/middle/instantiation.html","title":"子类对象实例化全过程","lang":"zh-CN","frontmatter":{"date":"2022-11-21T00:00:00.000Z","category":"基础","tag":["JAVA"]},"headers":[],"git":{"createdTime":1669474184000,"updatedTime":1669474184000,"contributors":[{"name":"MonkeyBoss","email":"1912290362@qq.com","commits":1}]},"readingTime":{"minutes":0.82,"words":246},"filePathRelative":"java/java-basic/object/middle/instantiation.md","localizedDate":"2022年11月21日","excerpt":"<h1> 子类对象实例化全过程</h1>\\n<p>理解即可</p>\\n<ol>\\n<li>\\n<p>从结果上看：继承性</p>\\n<p>子类继承父类以后，就获取了父类中声明的属性或方法。</p>\\n<p>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p>\\n</li>\\n<li>\\n<p>从过程上看：\\n当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了<code>java.lang.Object</code>\\n类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p>\\n<p></p>\\n</li>\\n<li>\\n<p>强调说明\\n虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为<code>new</code>的子类对象。\\n</p>\\n</li>\\n</ol>"}');export{e as data};
