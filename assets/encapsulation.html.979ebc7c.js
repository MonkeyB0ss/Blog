import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as n,e as s}from"./app.22b533d7.js";const c="/Blog/assets/modifier.b249285e.png",o={},t=s(`<h1 id="面向对象的特征一-封装性" tabindex="-1"><a class="header-anchor" href="#面向对象的特征一-封装性" aria-hidden="true">#</a> 面向对象的特征一：封装性</h1><h3 id="为什么要引入封装性❓" tabindex="-1"><a class="header-anchor" href="#为什么要引入封装性❓" aria-hidden="true">#</a> 为什么要引入封装性❓</h3><p>我们程序设计追求<code>高内聚</code>，<code>低耦合</code>。</p><p><code>高内聚</code> ：类的内部数据操作细节自己完成，不允许外部干涉；<br><code>低耦合</code> ：仅对外暴露少量的方法用于使用。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p></div><h3 id="问题引入" tabindex="-1"><a class="header-anchor" href="#问题引入" aria-hidden="true">#</a> 问题引入</h3><p>当我们创建一个类的对象以后，我们可以通过<code>对象.属性</code> 的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs() 同时，我们需要避免用户再使用<code>对象.属性</code>的方式对属性进行赋值。则需要将属性声明为私有的(<code>private</code>).</p><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>此时，针对于属性就体现了封装性。</p></div><h3 id="封装性思想具体的代码体现" tabindex="-1"><a class="header-anchor" href="#封装性思想具体的代码体现" aria-hidden="true">#</a> 封装性思想具体的代码体现</h3><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">double</span> radius<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRadius</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getRadius</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> radius<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>体现二：不对外暴露的私有的方法</p><p>体现三：单例模式（将构造器私有化）</p><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p><h3 id="java规定的四种权限修饰符" tabindex="-1"><a class="header-anchor" href="#java规定的四种权限修饰符" aria-hidden="true">#</a> Java规定的四种权限修饰符</h3><ol><li>权限从小到大顺序为：<code>private</code> &lt; <code>缺省</code> &lt; <code>protected</code> &lt; <code>public</code></li><li>具体的修饰范围： <img src="`+c+'" alt="img.png" loading="lazy"></li><li>权限修饰符可用来修饰的结构说明：<br> 4种权限都可以用来修饰类的内部结构：<code>属性</code>、<code>方法</code>、<code>构造器</code>、<code>内部类</code><br> 修饰类的话，<mark>只能</mark>使用：<code>缺省</code>、<code>public</code></li></ol>',16),d=[t];function i(p,l){return e(),n("div",null,d)}const h=a(o,[["render",i],["__file","encapsulation.html.vue"]]);export{h as default};
