import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,e}from"./app.c62a3edb.js";const t="/Blog/assets/img.f3da7201.png",p="/Blog/assets/img_1.db86e867.png",l="/Blog/assets/img_2.69d39c7f.png",i="/Blog/assets/img_3.4caa9ca6.png",c={},o=e('<h1 id="volatile和jmm内存模型的可见性" tabindex="-1"><a class="header-anchor" href="#volatile和jmm内存模型的可见性" aria-hidden="true">#</a> Volatile和JMM内存模型的可见性</h1><ul><li>JUC（java.util.concurrent） <ul><li>进程和线程 <ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行 <ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC下的三个包 <ul><li>java.util.concurrent <ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h2 id="谈谈对volatile的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对volatile的理解" aria-hidden="true">#</a> 谈谈对Volatile的理解</h2><p>Volatile在日常的单线程环境是应用不到的</p><ul><li>Volatile是Java虚拟机提供的<code>轻量级</code>的同步机制（三大特性） <ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul></li></ul><h2 id="jmm是什么" tabindex="-1"><a class="header-anchor" href="#jmm是什么" aria-hidden="true">#</a> JMM是什么</h2><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code> ，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img src="'+t+'" alt="img.png"></p><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>上面提到了两个概念：主内存 和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝</li></ul><p><img src="'+p+`" alt="img_1.png"></p></li></ul><p>即：JMM内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h2 id="缓存一致性" tabindex="-1"><a class="header-anchor" href="#缓存一致性" aria-hidden="true">#</a> 缓存一致性</h2><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了总线嗅探技术</p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有MSI、MESI等等。</p><h3 id="mesi" tabindex="-1"><a class="header-anchor" href="#mesi" aria-hidden="true">#</a> MESI</h3><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，会发出信号通知其它CPU将该内存变量的缓存行设置为无效，因此当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h3 id="总线嗅探" tabindex="-1"><a class="header-anchor" href="#总线嗅探" aria-hidden="true">#</a> 总线嗅探</h3><p>那么是如何发现数据是否失效呢？</p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h3 id="总线风暴" tabindex="-1"><a class="header-anchor" href="#总线风暴" aria-hidden="true">#</a> 总线风暴</h3><p>总线嗅探技术有哪些缺点？</p><p>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。</p><h2 id="jmm的特性" tabindex="-1"><a class="header-anchor" href="#jmm的特性" aria-hidden="true">#</a> JMM的特性</h2><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h2 id="可见性代码验证" tabindex="-1"><a class="header-anchor" href="#可见性代码验证" aria-hidden="true">#</a> 可见性代码验证</h2><p>但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 假设是主物理内存
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyData</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addTo60</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>number <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 验证volatile的可见性
 * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// 资源类</span>
        <span class="token class-name">MyData</span> myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;\\t come in&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 线程睡眠3秒，假设在进行运算</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 修改number的值</span>
            myData<span class="token punctuation">.</span><span class="token function">addTo60</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 输出修改后的值</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;\\t update number value:&quot;</span> <span class="token operator">+</span> myData<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;AAA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>myData<span class="token punctuation">.</span>number <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>
        <span class="token comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;\\t mission is over&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token doc-comment comment">/**
         * 最后输出结果：
         * AAA	 come in
         * AAA	 update number value:60
         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性
         */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为</p><p><img src="`+l+`" alt="img_2.png"></p><p>最后线程没有停止，并行没有输出 mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</p><p>当我们修改MyData类中的成员变量时，并且添加volatile关键字修饰</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 假设是主物理内存
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyData</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
     */</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addTo60</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>number <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出的结果为：</p><p><img src="`+i+'" alt="img_3.png"></p><p>主线程也执行完毕了，说明volatile修饰的变量，是具备JVM轻量级同步机制的，能够感知其它线程的修改后的值。</p>',41),u=[o];function d(r,k){return s(),a("div",null,u)}const b=n(c,[["render",d],["__file","Volatile和JMM内存模型的可见性.html.vue"]]);export{b as default};
